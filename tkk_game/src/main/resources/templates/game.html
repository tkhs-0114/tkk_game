<!DOCTYPE html>
<html lang="ja" xmlns:th="http://www.thymeleaf.org">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link th:href="@{/css/game.css}" rel="stylesheet">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Yuji+Boku&display=swap" rel="stylesheet">
  <title>ゲーム</title>
  <script th:inline="javascript">
    const ban = /*[[${ban}]]*/ null;
    const gameId = /*[[${gameId}]]*/ 'defaultGameId';
    const playerStatus = /*[[${playerStatus}]]*/ 'defaultStatus';
    const errMessage = /*[[${errMessage}]]*/ null;
    const game = /*[[${game}]]*/ null;
    const loginPlayerName = /*[[${#authentication.name}]]*/ null;
    const haveKoma = /*[[${haveKoma}]]*/ null;
    const enemyHaveKoma = /*[[${enemyHaveKoma}]]*/ null;
    const GAME_END = /*[[${GAME_END}]]*/ false;
    const isWinner = /*[[${isWinner}]]*/ null;
    const turnChanged = /*[[${turnChanged}]]*/ false;

    console.log(game);
    console.log(ban);
    console.log(haveKoma);

    let selectedX = null;
    let selectedY = null;
    let selectedHaveKoma = false;
    let haveKomaIndex = null;
    let isDetailLocked = false; // 詳細表示の固定状態
    let isInternalNavigation = false; // ゲーム内での正当な遷移かどうかを判別

    // 駒の文字数に応じてフォントサイズを動的に調整する関数
    function adjustKomaFontSize(element) {
      if (!element) return;
      const textContent = element.textContent.trim();
      const charCount = textContent.length;
      
      // 文字数に応じてフォントサイズを決定
      let fontSize;
      if (charCount <= 2) {
        fontSize = '2rem';
      } else if (charCount <= 3) {
        fontSize = '1.4rem';
      } else if (charCount <= 4) {
        fontSize = '1rem';
      } else {
        fontSize = '0.8rem';
      }
      
      element.style.fontSize = fontSize;
    }

    // すべての駒のサイズを調整する関数
    function adjustAllKomaFontSizes() {
      // 盤面の駒
      document.querySelectorAll('#board-container .cell.koma').forEach(element => {
        adjustKomaFontSize(element);
      });
      // 持ち駒
      document.querySelectorAll('#haveKoma-container .cell.koma').forEach(element => {
        adjustKomaFontSize(element);
      });
      // 相手の持ち駒
      document.querySelectorAll('#haveKoma_E-container .cell.koma').forEach(element => {
        adjustKomaFontSize(element);
      });
    }

    // 配列のインデックスを盤面の座標に変換
    function Xa2b(arrayIndex) {
      return arrayIndex - (ban.board.length - 1) / 2;
    }
    function Ya2b(arrayIndex) {
      return arrayIndex - (ban.board[0].length - 1) / 2;
    }
    function b2Xa(boardX) {
      return boardX + (ban.board.length - 1) / 2;
    }
    function b2Ya(boardY) {
      return boardY + (ban.board[0].length - 1) / 2;
    }

    function setSelectedCell(x, y) {
      selectedX = x;
      selectedY = y;
      selectedHaveKoma = false;
      console.log(`Selected cell: (${x}, ${y})`);

      // 持ち駒のハイライトをクリア
      document.querySelectorAll('#haveKoma-container .cell').forEach(cell => {
        cell.classList.remove('selected');
      });

      highlightMovableCells(x, y);
    }
    function sendMove(x, y) {
      if (selectedHaveKoma) {
        isInternalNavigation = true;
        window.location.href = `/game/putKoma?index=${haveKomaIndex}&toX=${x}&toY=${y}`;
      } else {
        if (selectedX === null || selectedY === null) {
          alert('セルが選択されていません');
          return;
        } else {
          let willUpdate = false;
          // 成れる場合
          // 敵陣の1段目（盤面の端）に入る場合のみ成れる
          const enemyAreaBoundary = -Math.floor(ban.board.length / 2);
          const selectedCell = ban.board[b2Xa(selectedX)][b2Ya(selectedY)];
          const canUpdate = (selectedY === enemyAreaBoundary || y === enemyAreaBoundary) && selectedCell.updateKoma !== -1 && selectedCell.updateKoma !== selectedCell.id;
          if (canUpdate) {
            willUpdate = window.confirm('駒を成りますか？\nOK: 成る\nキャンセル: 成らない');
          }
          isInternalNavigation = true;
          window.location.href = `/game/move?fromX=${selectedX}&fromY=${selectedY}&toX=${x}&toY=${y}&isUpdate=${willUpdate}`;
        }
      }

    }
    // サーバーAPIから移動可能マスを取得してハイライト
    async function highlightMovableCells(fromX, fromY) {
      // 既存のハイライトをクリア
      document.querySelectorAll('#board-container .cell').forEach(cell => {
        cell.classList.remove('selected', 'movable');
      });

      // 選択中のセルをハイライト
      const selectedCell = document.querySelector(`#board-container [data-x="${fromX}"][data-y="${fromY}"]`);
      if (selectedCell) selectedCell.classList.add('selected');

      // サーバーから移動可能マスを取得
      const response = await fetch(`/game/movable?x=${fromX}&y=${fromY}`);
      const movableCells = await response.json();

      for (const [x, y] of movableCells) {
        const cell = document.querySelector(`#board-container [data-x="${x}"][data-y="${y}"]`);
        if (cell) cell.classList.add('movable');
      }
    }

    // 駒の詳細を表示
    function showKomaDetail(cell, isClick = false) {
      const komaView = document.getElementById('koma-view');

      // クリック時は固定表示をトグル
      if (isClick) {
        if (isDetailLocked && komaView.dataset.currentKoma === JSON.stringify(cell)) {
          // 同じ駒を再クリック → 固定解除
          isDetailLocked = false;
          komaView.innerHTML = '';
          komaView.classList.remove('locked');
          return;
        }
        isDetailLocked = true;
        komaView.classList.add('locked');
      }

      // 固定表示中はhoverを無視
      if (isDetailLocked && !isClick) {
        return;
      }

      if (!cell || !cell.name) {
        if (!isDetailLocked) {
          komaView.innerHTML = '';
        }
        return;
      }

      komaView.dataset.currentKoma = JSON.stringify(cell);
      console.log('Showing koma detail:', cell);
      const owner = cell.owner?.name === loginPlayerName ? '自分' : '相手';

      // ルールを日本語に変換
      const ruleNameMap = {
        'UP': '上',
        'DOWN': '下',
        'LEFT': '左',
        'RIGHT': '右',
        'UP_LEFT': '左上',
        'UP_RIGHT': '右上',
        'DOWN_LEFT': '左下',
        'DOWN_RIGHT': '右下',
        'LINE_UP': '上(直線)',
        'LINE_DOWN': '下(直線)',
        'LINE_LEFT': '左(直線)',
        'LINE_RIGHT': '右(直線)',
        'LINE_UP_LEFT': '左上(直線)',
        'LINE_UP_RIGHT': '右上(直線)',
        'LINE_DOWN_LEFT': '左下(直線)',
        'LINE_DOWN_RIGHT': '右下(直線)',
        'JUMP_UP_LEFT': '上左(飛び越え)',
        'JUMP_UP_RIGHT': '上右(飛び越え)',
        'JUMP_DOWN_LEFT': '下左(飛び越え)',
        'JUMP_DOWN_RIGHT': '下右(飛び越え)',
        'JUMP_LEFT_UP': '左上(飛び越え)',
        'JUMP_LEFT_DOWN': '左下(飛び越え)',
        'JUMP_RIGHT_UP': '右上(飛び越え)',
        'JUMP_RIGHT_DOWN': '右下(飛び越え)'
      };
      const rules = cell.rules?.map(r => ruleNameMap[r] || r).join('<br>・') || 'なし';

      // スキルを日本語に変換
      const skillNameMap = {
        'NULL': 'なし',
        'STEALTH': '動きが１ターン遅れて見える',
      };
      const skill = cell.skill ? (skillNameMap[cell.skill] || cell.skill) : 'なし';

      console.log('cell:', cell);
      const lockHint = isDetailLocked ? '<p style="font-size: 0.8em; color: #999;">(固定表示中 - もう一度クリックで解除)</p>' : '<p style="font-size: 0.8em; color: #999;">(右クリックで固定表示)</p>';
      komaView.innerHTML = `
        <div class="koma-detail">
          <p><strong>${cell.name}</strong></p>
          <p>所有者: ${owner}</p>
          <p>スキル: ${skill}</p>
          <p>移動方向:<br>・${rules}</p>
          ${lockHint}
        </div>
      `;
    }

    function drawBoard() {
      const boardContainer = document.getElementById('board-container');
      if (!ban || !ban.board) {
        boardContainer.innerHTML = '<p>盤面データがありません</p>';
        return;
      }

      let html = '<table border="1">';

      const boardLength = ban.board.length;

      for (let y = 0; y < boardLength; y++) {
        html += '<tr>';
        for (let x = 0; x < boardLength; x++) {
          const cell = ban.board[x][y];

          // GAME_ENDの場合はクリックイベントを設定しない
          let cellContent;
          const hover = `onmouseenter="showKomaDetail(ban.board[${x}][${y}])" onmouseleave="showKomaDetail(null)" oncontextmenu="event.preventDefault(); event.stopPropagation(); showKomaDetail(ban.board[${x}][${y}], true);"`;
          if (GAME_END) {
            cellContent = (cell && cell.name) ?
              `<div class="cell koma${cell.owner.name !== loginPlayerName ? ' enemy' : ''}" ${hover}>${cell.name}</div>`
              : `<div class="cell">　</div>`;
          } else {
            const boardX = Xa2b(x);
            const boardY = Ya2b(y);
            cellContent = (cell && cell.name && (cell.owner.name === loginPlayerName)) ?
              `<div class="cell koma" data-x="${boardX}" data-y="${boardY}" onClick="setSelectedCell(${boardX}, ${boardY})" ${hover}>${cell.name}</div>`
              : (cell && cell.name) ?
                `<div class="cell koma enemy" data-x="${boardX}" data-y="${boardY}" onClick="sendMove(${boardX}, ${boardY})" ${hover}>${cell.name}</div>`
                : `<div class="cell" data-x="${boardX}" data-y="${boardY}" onClick="sendMove(${boardX}, ${boardY})">　</div>`;
          }
          html += `<td>${cellContent}</td>`;
        }
        html += '</tr>';
      }

      html += '</table>';
      boardContainer.innerHTML = html;
      adjustAllKomaFontSizes();
    }

    function selectHaveKoma(index) {
      selectedHaveKoma = true;
      haveKomaIndex = index;

      // 盤面のハイライトをクリア
      document.querySelectorAll('#board-container .cell').forEach(cell => {
        cell.classList.remove('selected', 'movable');
      });

      // 持ち駒のハイライトをクリア
      document.querySelectorAll('#haveKoma-container .cell').forEach(cell => {
        cell.classList.remove('selected');
      });

      // 選択した持ち駒をハイライト
      const selectedCell = document.querySelector(`#haveKoma-container .cell[data-index="${index}"]`);
      if (selectedCell) selectedCell.classList.add('selected');
    }
    function drawHaveKoma(komaData, containerId, isClickable = false) {
      const komaContainer = document.getElementById(containerId);
      if (!komaData) {
        komaContainer.innerHTML = '<p>盤面データがありません</p>';
        return;
      }

      let html = '<table>';
      html += '<tr>';
      for (let i = 0; i < komaData.length; i++) {
        const cell = komaData[i];
        const komaArray = containerId === 'haveKoma-container' ? 'haveKoma' : 'enemyHaveKoma';
        const hover = `onmouseenter="showKomaDetail(${komaArray}[${i}])" onmouseleave="showKomaDetail(null)" oncontextmenu="event.preventDefault(); showKomaDetail(${komaArray}[${i}], true);"`;
        const cellContent = (isClickable && !GAME_END)
          ? `<div class="cell koma" data-index="${i}" onClick="selectHaveKoma(${i})" ${hover}>${cell.name}</div>`
          : `<div class="cell koma" ${hover}>${cell.name}</div>`;
        html += `<td>${cellContent}</td>`;
      }
      html += '</tr>';
      html += '</table>';
      komaContainer.innerHTML = html;
      adjustAllKomaFontSizes();
    }

    // 勝利・敗北演出を表示する関数
    function showResultOverlay(isWin) {
      const overlay = document.createElement('div');
      overlay.className = 'result-overlay ' + (isWin ? 'win' : 'lose');

      const content = document.createElement('div');
      content.className = 'result-content';

      const resultText = document.createElement('div');
      resultText.className = 'result-text';
      resultText.textContent = isWin ? '勝利' : '敗北';

      const subText = document.createElement('div');
      subText.className = 'result-subtext';
      subText.textContent = isWin ? 'おめでとうございます！' : 'また挑戦してください';

      const endSound = isWin ? new Audio('/sound/win.mp3') : new Audio('/sound/lose.mp3');
      endSound.play().catch(e => console.log('音声再生エラー:', e));

      content.appendChild(resultText);
      content.appendChild(subText);
      overlay.appendChild(content);
      document.body.appendChild(overlay);

      // アニメーション後にフェードアウト
      setTimeout(() => {
        overlay.classList.add('fade-out');
        setTimeout(() => {
          overlay.remove();
        }, 1000);
      }, 3000);
    }


    window.onload = function () {
      // 盤面を描画
      drawBoard();
      drawHaveKoma(haveKoma, 'haveKoma-container', true);
      drawHaveKoma(enemyHaveKoma, 'haveKoma_E-container', false);

      // ターン変更時に音を再生
      if (turnChanged) {
        const komaSound = new Audio('/sound/koma.mp3');
        komaSound.play().catch(e => console.log('音声再生エラー:', e));
      }

      // エラーメッセージがあれば表示
      if (errMessage) {
        alert(errMessage);
      }

      console.log('Player Status:', playerStatus);

      // 勝利・敗北演出
      if (GAME_END && isWinner !== null) {
        showResultOverlay(isWinner);
      }

      // ページ離脱時の切断通知（ブラウザを閉じた時、他のページに移動した時）
      window.addEventListener('beforeunload', function (event) {
        // ゲーム内での正当な遷移の場合は切断通知を送らない
        if (!isInternalNavigation && !GAME_END) {
          // sendBeaconを使用して非同期でサーバーに通知
          navigator.sendBeacon('/game/disconnect', new Blob([JSON.stringify({ reason: 'page_unload' })], { type: 'application/json' }));
        }
      });

      if (playerStatus === 'GAME_WAITING' || playerStatus === 'GAME_STARTING') {
        // SSE接続でターン情報を受信
        const sse = new EventSource(`/game/turn?gameId=${gameId}`);
        sse.onmessage = function (event) {
          const isNextTurn = JSON.parse(event.data);
          console.log('Is next turn:', isNextTurn);
          if (isNextTurn) {
            isInternalNavigation = true;
            window.location.href = `/game?turnChanged=true`;
          }
        };

        // 相手プレイヤーの切断通知を受信
        sse.addEventListener('disconnect', function (event) {
          const disconnectedPlayer = event.data;
          console.log('Player disconnected:', disconnectedPlayer);
          alert(`${disconnectedPlayer} さんが切断しました。マッチング画面に戻ります。`);
          sse.close();
          isInternalNavigation = true;
          window.location.href = '/match';
        });

        // SSE接続エラー時の処理
        sse.onerror = function (event) {
          console.error('SSE connection error:', event);
        };
      }

    };
  </script>
</head>

<body>
  <div class="game-header">
    <div class="game-status">
      <span th:if="${playerStatus.name() == 'GAME_WAITING'}" class="status-text waiting-turn">相手の手番</span>
      <span th:if="${playerStatus.name() == 'GAME_STARTING' or playerStatus.name() == 'GAME_THINKING'}"
        class="status-text your-turn">あなたの手番</span>
      <span th:if="${GAME_END}" class="status-text game-end">対局終了</span>
    </div>
    <div th:if="${GAME_END}" class="game-result">
      <span th:if="${isWinner}" class="result-text win">勝利</span>
      <span th:if="${!isWinner}" class="result-text lose">敗北</span>
    </div>
    <div class="button-area">
      <a th:if="${GAME_END}" href="/home">ホームに戻る</a>
    </div>
  </div>
  <div class="game-container">
    <div class="frame have-koma-frame">
      <p>相手の持ち駒</p>
      <div id="haveKoma_E-container">
        <!-- 相手の持ち駒がここに表示されます -->
      </div>
    </div>
    <br>
    <div class="game-board-layout">
      <div id="board-container">
        <!-- 盤面がここに表示されます -->
      </div>
      <div class="frame" id="koma-view">
        <!-- 駒の詳細がここに表示されます -->
      </div>
    </div>
    <br>
    <div class="frame have-koma-frame">
      <p>自分の持ち駒</p>
      <div id="haveKoma-container">
        <!-- 持ち駒がここに表示されます -->
      </div>
    </div>
  </div>



  <div class="game-footer">
    <p class="room-id">Room ID: [[${gameId}]]</p>
  </div>


</body>

</html>

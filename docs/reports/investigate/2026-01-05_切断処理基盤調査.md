# 切断処理基盤調査レポート

## 調査日
2026年1月5日

## 調査目的
相手が切断した時（ブラウザクローズ、他サイトへの遷移、ネットワーク切断等）に、切断したプレイヤーと切断されたプレイヤーの両方に対して適切な処理を行うための基盤を構築する。

## 現状の切断検知実装

### 1. SSE (Server-Sent Events) の切断検知機能

#### 1.1 GameEventEmitterManager (tkk_game/src/main/java/team3/tkk_game/services/GameEventEmitterManager.java)
現在、以下のコールバック機能が実装されている：

```java
emitter.onCompletion(() -> removeEmitter(playerName));
emitter.onTimeout(() -> removeEmitter(playerName));
emitter.onError(e -> removeEmitter(playerName));
```

- **onCompletion**: 正常にSSE接続が完了した時に呼ばれる
- **onTimeout**: タイムアウト時に呼ばれる（現在は `Long.MAX_VALUE` で実質無効化）
- **onError**: エラー発生時（IOException等）に呼ばれる

#### 1.2 WaitRoomEventEmitterManager (tkk_game/src/main/java/team3/tkk_game/services/WaitRoomEventEmitterManager.java)
待機室でも同様の切断検知機能が実装されている：

```java
emitter.onCompletion(() -> removeEmitter(emitter));
emitter.onTimeout(() -> removeEmitter(emitter));
emitter.onError(e -> removeEmitter(emitter));
```

### 2. Spring MVC の SSE 切断検知の仕組み（調査結果）

Spring MVCのドキュメント（参考URL: https://spring.pleiades.io/spring-framework/reference/web/webmvc/mvc-ann-async.html）によると：

- **IOException**: クライアントが切断された場合、`emitter.send()` で IOException がスローされる
- **自動クリーンアップ**: Servlet コンテナが `AsyncListener` エラー通知を自動的に開始し、Spring MVC が `completeWithError` を呼び出す
- **定期的な通信の重要性**: 「クライアントが切断された場合は書き込みが失敗するため、定期的にデータを送信することが重要」

### 3. ブラウザ側の切断検知（調査結果）

MDN Web Docs（参考URL: https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events）によると：

#### 3.1 EventSource のエラーハンドリング

```javascript
evtSource.onerror = (err) => {
  console.error("EventSource failed:", err);
};
```

#### 3.2 接続の明示的な終了

```javascript
evtSource.close();
```

デフォルトでは、接続が切れると **自動的に再接続** される。

### 4. 他サイトへの遷移時の検知方法

#### 4.1 beforeunload イベント
ブラウザでページを離れる前に実行される：

```javascript
window.addEventListener('beforeunload', (event) => {
  // ページを離れる前の処理
  navigator.sendBeacon('/api/disconnect', JSON.stringify({ playerId: playerName }));
});
```

**注意点**:
- 通常のXHRやfetchは完了しない可能性がある
- `navigator.sendBeacon()` を使用することで、ページ離脱時でも確実にリクエストを送信できる

#### 4.2 visibilitychange イベント
タブが非表示になった時に実行される：

```javascript
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // タブが非表示になった時の処理
    console.log('ページが非表示になりました');
  }
});
```

### 5. igakilab/springboot_samples の参考実装

Sample58Controller（参考コード）:
```java
@GetMapping("step1")
public SseEmitter pushCount58(@AuthenticationPrincipal UserDetails user) {
  SseEmitter emitter = new SseEmitter(60000L); // タイムアウト時間を60秒に設定
  
  // Emitterをマップに保存
  String semapId = "" + this.emitterCounter;
  this.semap.put(semapId, emitter);
  
  try {
    this.counter58.count(emitter, role);
  } catch (IOException e) {
    logger.warn("Exception:" + e.getClass().getName() + ":" + e.getMessage());
    logger.info("emitter is removed");
    this.semap.remove(semapId);
  }
  return emitter;
}
```

**ポイント**:
- Emitter をマップで管理し、プレイヤー名と紐付け
- IOException 発生時に明示的にマップから削除
- タイムアウトを設定（60秒）

## 切断の種類と検知方法

| 切断の種類 | 検知方法 | 検知タイミング |
|-----------|---------|--------------|
| ブラウザクローズ | `beforeunload` イベント + `navigator.sendBeacon()` | 即時 |
| 他サイトへの遷移 | `beforeunload` イベント + `navigator.sendBeacon()` | 即時 |
| タブを閉じる | `beforeunload` イベント + `navigator.sendBeacon()` | 即時 |
| ネットワーク切断 | SSE の `onError` + サーバー側の `IOException` | 次回 send 時（最大1秒後） |
| ブラウザクラッシュ | SSE タイムアウト（設定が必要） | タイムアウト時間経過後 |
| アプリケーション強制終了 | SSE タイムアウト（設定が必要） | タイムアウト時間経過後 |

## 推奨される切断処理基盤の設計

### 1. DisconnectionHandler サービスの新設

プレイヤーの切断を一元的に処理するサービスクラス：

```java
@Service
public class DisconnectionHandler {
  
  /**
   * プレイヤーが切断した時の処理
   * @param playerName 切断したプレイヤー名
   * @param reason 切断理由（"INTENTIONAL", "NETWORK_ERROR", "TIMEOUT" 等）
   */
  public void handlePlayerDisconnection(String playerName, String reason) {
    // 1. ゲームの取得
    // 2. 相手プレイヤーへの通知
    // 3. ゲームステータスの更新
    // 4. SSE接続のクリーンアップ
  }
}
```

### 2. クライアント側の切断通知エンドポイント

```java
@PostMapping("/game/disconnect")
@ResponseBody
public void notifyDisconnection(Principal principal) {
  String playerName = principal.getName();
  disconnectionHandler.handlePlayerDisconnection(playerName, "INTENTIONAL");
}
```

### 3. JavaScript での beforeunload 実装

```javascript
window.addEventListener('beforeunload', (event) => {
  // SSE接続を明示的に切断
  if (sse) {
    sse.close();
  }
  
  // サーバーに切断を通知
  navigator.sendBeacon('/game/disconnect', new Blob([JSON.stringify({
    action: 'disconnect'
  })], { type: 'application/json' }));
});
```

### 4. SSE タイムアウトの設定

現在 `Long.MAX_VALUE` で実質無効化されているタイムアウトを適切な時間に設定：

```java
// 例: 30秒のタイムアウト
SseEmitter emitter = new SseEmitter(30000L);
```

### 5. ハートビート（定期送信）の実装

定期的にダミーデータを送信することで、切断を早期に検知：

```java
@Scheduled(fixedRate = 5000) // 5秒ごと
public void sendHeartbeat() {
  // すべてのアクティブなEmitterにハートビートを送信
}
```

## 実装時の注意点

1. **切断理由の識別**: 意図的な切断（ページ遷移等）と非意図的な切断（ネットワークエラー等）を区別する
2. **相手への通知方法**: SSEを使って相手プレイヤーに切断を通知する
3. **再接続の扱い**: ブラウザの自動再接続機能をどう扱うか（`sse.close()` で明示的に切断するか）
4. **ゲームステータスの管理**: 切断時にゲームを中断・終了・継続のどれにするか
5. **タイムアウトの調整**: 短すぎると誤検知、長すぎると検知が遅れる
6. **リソースのクリーンアップ**: Emitter、ゲームオブジェクト、セッション等の適切な解放

## 参考URL

- Spring MVC 非同期リクエスト処理: https://spring.pleiades.io/spring-framework/reference/web/webmvc/mvc-ann-async.html
- MDN Server-Sent Events: https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events
- igakilab/springboot_samples: https://github.com/igakilab/springboot_samples

## 結論

現在の実装では基本的な切断検知機能（`onError`, `onTimeout`, `onCompletion`）は実装されているが、以下が不足している：

1. **切断時の処理内容が未定義**: `removeEmitter()` でリソース解放のみ
2. **相手プレイヤーへの通知機能がない**
3. **ブラウザ側からの明示的な切断通知がない**（beforeunload 未実装）
4. **タイムアウトが実質無効**（`Long.MAX_VALUE`）
5. **ハートビート機能がない**

これらを実装することで、安定した切断検知・処理基盤を構築できる。

# ログイン機能実装方法調査レポート

## 調査日時
2025年11月11日

## 調査目的
Spring Bootアプリケーションにログイン機能を実装する方法を、igakilab/springboot_samplesリポジトリを参考にして調査する。

## 参考リポジトリ
https://github.com/igakilab/springboot_samples

## 調査内容

### 1. 必要な依存関係

#### build.gradleへの追加
プロジェクトにSpring Securityを導入するため、以下の依存関係が必要です：

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.thymeleaf.extras:thymeleaf-extras-springsecurity6'
    // その他の依存関係...
}
```

**注意点**：
- Spring Securityを有効化すると、デフォルトですべてのエンドポイントが認証を要求するようになります
- 開発初期段階でセキュリティ機能が不要な場合は、一時的にコメントアウトすることも可能です

### 2. セキュリティ設定クラスの作成

認証・認可を制御するための設定クラスを作成します。

#### ファイルパス
`src/main/java/{パッケージ名}/security/SecurityConfig.java`

#### 実装例（参考: Sample3AuthConfiguration.java）

```java
package team3.tkk_game.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

  /**
   * 認可処理に関する設定（認証されたユーザがどこにアクセスできるか）
   */
  @Bean
  public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http.formLogin(login -> login
        .permitAll())  // ログインフォームは全員アクセス可能
        .logout(logout -> logout
            .logoutUrl("/logout")
            .logoutSuccessUrl("/"))  // ログアウト後にトップページにリダイレクト
        .authorizeHttpRequests(authz -> authz
            .requestMatchers("/game/**").authenticated()  // /game/以下は認証が必要
            .anyRequest().permitAll())  // 上記以外は全員アクセス可能
        .csrf(csrf -> csrf
            .ignoringRequestMatchers("/h2-console/*"))  // H2コンソール用にCSRF対策を無効化（必要に応じて）
        .headers(headers -> headers
            .frameOptions(frameOptions -> frameOptions
                .sameOrigin()));  // 同一オリジンからのframeを許可
    return http.build();
  }

  /**
   * 認証処理に関する設定（誰がどのようなロールでログインできるか）
   *
   * インメモリ認証の例
   */
  @Bean
  public InMemoryUserDetailsManager userDetailsService() {
    // ユーザ名、パスワード、ロールを指定してbuildする
    // パスワードはBCryptでハッシュ化されているため、{bcrypt}をつける
    // ハッシュ化せずに平文でパスワードを指定する場合は{noop}をつける

    // user1/p@ss
    UserDetails user1 = User.withUsername("user1")
        .password("{bcrypt}$2y$10$ngxCDmuVK1TaGchiYQfJ1OAKkd64IH6skGsNw1sLabrTICOHPxC0e")
        .roles("USER")
        .build();

    // user2/p@ss
    UserDetails user2 = User.withUsername("user2")
        .password("{bcrypt}$2y$10$ngxCDmuVK1TaGchiYQfJ1OAKkd64IH6skGsNw1sLabrTICOHPxC0e")
        .roles("USER")
        .build();

    // admin/p@ss
    UserDetails admin = User.withUsername("admin")
        .password("{bcrypt}$2y$10$ngxCDmuVK1TaGchiYQfJ1OAKkd64IH6skGsNw1sLabrTICOHPxC0e")
        .roles("ADMIN")
        .build();

    // 生成したユーザをInMemoryUserDetailsManagerに渡す
    return new InMemoryUserDetailsManager(user1, user2, admin);
  }
}
```

**重要なポイント**：
1. **`@Configuration`と`@EnableWebSecurity`**: Spring Securityを有効化するために必須のアノテーション
2. **`filterChain`メソッド**: 認可（誰がどこにアクセスできるか）を設定
3. **`userDetailsService`メソッド**: 認証（誰がログインできるか）を設定

### 3. パスワードのハッシュ化

パスワードは平文で保存せず、BCryptでハッシュ化する必要があります。

#### パスワードのプレフィックス
- **`{bcrypt}`**: BCryptでハッシュ化されたパスワード
- **`{noop}`**: 平文パスワード（開発時のみ使用、本番環境では非推奨）

#### BCryptハッシュ値の生成方法
パスワード「p@ss」のBCryptハッシュ値の例：
```
$2y$10$ngxCDmuVK1TaGchiYQfJ1OAKkd64IH6skGsNw1sLabrTICOHPxC0e
```

### 4. コントローラーでのログインユーザー情報取得

#### Principalを使用した方法

```java
import java.security.Principal;
import org.springframework.stereotype.Controller;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class GameController {

  @GetMapping("/game")
  public String game(ModelMap model, Principal prin) {
    String loginUser = prin.getName();  // ログインユーザ名を取得
    model.addAttribute("userName", loginUser);
    return "game.html";
  }
}
```

#### @AuthenticationPrincipalを使用した方法（ロール情報も取得可能）

```java
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class GameController {

  @GetMapping("/game/advanced")
  public String gameAdvanced(@AuthenticationPrincipal UserDetails user, ModelMap model) {
    String userName = user.getUsername();  // ユーザ名を取得
    String authorities = user.getAuthorities().toString();  // ロール情報を取得

    model.addAttribute("userName", userName);
    model.addAttribute("roles", authorities);
    return "game.html";
  }
}
```

### 5. Thymeleafテンプレートでの実装

#### ネームスペースの追加
Thymeleafテンプレートの`<html>`タグに以下を追加：

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:sec="http://www.springframework.org/schema/security">
```

#### ログインユーザー名の表示

```html
<!-- Javaコード側で渡した変数を使用 -->
<h1>ようこそ! [[${userName}]]</h1>

<!-- Thymeleafから直接認証情報を取得 -->
<h1>ようこそ! <span sec:authentication="name"></span></h1>
```

#### ログアウトリンク

```html
<a href="/logout">ログアウト</a>
```

#### ロールに応じた表示制御

```html
<!-- ADMINロールを持つユーザーのみに表示 -->
<div sec:authorize="hasRole('ROLE_ADMIN')">
  <p>管理者専用コンテンツ</p>
</div>

<!-- USERロールを持つユーザーのみに表示 -->
<div sec:authorize="hasRole('ROLE_USER')">
  <p>ユーザー専用コンテンツ</p>
</div>
```

### 6. 認証が必要なパスの設定

`SecurityConfig.java`の`filterChain`メソッド内で設定：

```java
.authorizeHttpRequests(authz -> authz
    .requestMatchers("/game/**").authenticated()  // /game/以下は認証が必要
    .requestMatchers("/admin/**").hasRole("ADMIN")  // /admin/以下はADMINロールが必要
    .anyRequest().permitAll())  // それ以外は誰でもアクセス可能
```

### 7. データベース認証への拡張（将来的な実装）

現在の実装例はインメモリ認証（メモリ上にユーザー情報を保持）ですが、将来的にデータベースでユーザー管理を行う場合は以下のような拡張が必要になります：

1. **ユーザー情報を格納するテーブルの作成**
2. **MyBatisまたはJPAでのユーザー情報の取得**
3. **UserDetailsServiceの実装クラスの作成**
4. **パスワードエンコーダーの設定**

## 実装の流れ

### ステップ1: 依存関係の追加
`build.gradle`にSpring Securityとthymeleaf-extras-springsecurityを追加

### ステップ2: セキュリティ設定クラスの作成
`SecurityConfig.java`を作成し、認証・認可の設定を行う

### ステップ3: コントローラーの実装
`Principal`を引数に追加してログインユーザー情報を取得

### ステップ4: Thymeleafテンプレートの修正
ネームスペースを追加し、ログインユーザー名やログアウトリンクを表示

### ステップ5: 動作確認
- アプリケーションを起動
- 認証が必要なパスにアクセス
- ログインフォームが表示されることを確認
- 設定したユーザー名とパスワードでログイン
- ログイン後、ユーザー名が表示されることを確認
- ログアウトが正常に動作することを確認

## 推奨事項

1. **段階的な実装**: まずはインメモリ認証で基本的な機能を実装し、動作確認後にデータベース認証へ移行することを推奨
2. **パスワードの安全性**: 本番環境では必ずBCryptでハッシュ化したパスワードを使用すること
3. **CSRF対策**: 特別な理由がない限り、CSRF対策は有効にしておくこと
4. **ロールベースのアクセス制御**: 必要に応じて、複数のロール（USER、ADMIN等）を使い分けること
5. **テスト**: ログイン機能の実装後は、認証済み/未認証の両方の状態で各機能が正しく動作するかテストすること

## 参考URL
- https://github.com/igakilab/springboot_samples
- 特に参考になるファイル:
  - `src/main/java/oit/is/inudaisuki/springboot_samples/security/Sample3AuthConfiguration.java`
  - `src/main/java/oit/is/inudaisuki/springboot_samples/controller/Sample31Controller.java`
  - `src/main/resources/templates/sample31.html`
